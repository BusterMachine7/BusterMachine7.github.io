<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="algorithm," />










<meta name="description" content="最近读了一下flp的证明，翻译下。 需要解决的问题如果要解决的问题是这样的或者比这约束还强那就可能一直达成不了一致了。  一个一致性协议P运行在包含N个进程的异步系统，每个进程p有一个1位的输入寄存器xp，一个输出寄存器yp，xp和yp的值可以为(b，0，1)，以及一个无限容量的内部存储。输入和输出寄存器的值，程序计数器和内部存储器一起构成进程的内部状态。初始状态表示了除了输入寄存器以外的所有部分">
<meta name="keywords" content="algorithm">
<meta property="og:type" content="article">
<meta property="og:title" content="读一下flp impossibility的证明">
<meta property="og:url" content="https://bustermachine7.github.io/2018/01/03/flp-translation/index.html">
<meta property="og:site_name" content="YoRHa">
<meta property="og:description" content="最近读了一下flp的证明，翻译下。 需要解决的问题如果要解决的问题是这样的或者比这约束还强那就可能一直达成不了一致了。  一个一致性协议P运行在包含N个进程的异步系统，每个进程p有一个1位的输入寄存器xp，一个输出寄存器yp，xp和yp的值可以为(b，0，1)，以及一个无限容量的内部存储。输入和输出寄存器的值，程序计数器和内部存储器一起构成进程的内部状态。初始状态表示了除了输入寄存器以外的所有部分">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-01-05T11:55:41.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读一下flp impossibility的证明">
<meta name="twitter:description" content="最近读了一下flp的证明，翻译下。 需要解决的问题如果要解决的问题是这样的或者比这约束还强那就可能一直达成不了一致了。  一个一致性协议P运行在包含N个进程的异步系统，每个进程p有一个1位的输入寄存器xp，一个输出寄存器yp，xp和yp的值可以为(b，0，1)，以及一个无限容量的内部存储。输入和输出寄存器的值，程序计数器和内部存储器一起构成进程的内部状态。初始状态表示了除了输入寄存器以外的所有部分">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bustermachine7.github.io/2018/01/03/flp-translation/"/>





  <title>读一下flp impossibility的证明 | YoRHa</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YoRHa</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">chil[D]hood's end</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bustermachine7.github.io/2018/01/03/flp-translation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Type 2B">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YoRHa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">读一下flp impossibility的证明</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-03T16:50:30+08:00">
                2018-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/一致性/" itemprop="url" rel="index">
                    <span itemprop="name">一致性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>最近读了一下flp的证明，翻译下。</p>
<h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><p>如果要解决的问题是这样的或者比这约束还强那就可能一直达成不了一致了。</p>
<blockquote>
<p>一个一致性协议P运行在包含N个进程的异步系统，每个进程p有一个1位的输入寄存器xp，一个输出寄存器yp，xp和yp的值可以为(b，0，1)，以及一个无限容量的内部存储。输入和输出寄存器的值，程序计数器和内部存储器一起构成进程的内部状态。初始状态表示了除了输入寄存器以外的所有部分的初始值，yp的值起初是b，yp是0或1的状态看做<strong>确定状态</strong>，p根据状态转移函数切换到确定状态。一旦p进入确定状态，状态转移函数就不再能更改yp。整个系统P是由每个进程的状态转移函数以及xp的初始值确定的。</p>
<p>进程通过相互发送消息进行通信。消息可以看做(p, m)，其中p是目标进程的名称，m是来自特定集合内的“消息值”。消息系统维护一个称为缓冲区的集合，缓冲区内的消息已经被发送，但尚未确定到达。 它支持两个操作：</p>
<ol>
<li>send(p, m) : 将(p, m)放在缓冲区中。</li>
<li>receive(p) : 删除随意的(p, m)并返回m，此时(p, m)被认为到达，或者不做任何事情，返回null。</li>
</ol>
<p>就算缓冲区中有(p,m)也允许receive(p)返回有限次null，这样的话系统的行为是不确定的，除非receive是无限执行的，那样的话缓冲区内的所有消息可以确保都到达。</p>
</blockquote>
<p>考虑现实情况，receive当然是不必然成功的，其他约束都还比较宽松。<br>因为receive(p)是随意的在缓冲区内取消息的，消息是乱序到达的。另一方面，执行receive(p)就收到一个m之后receive(p)还是可以<br>进入确定状态后值就不再改变，receive失败也不会导致(p,m)从缓冲区删除。</p>
<blockquote>
<p>一个系统配置(configuration)可以看做是描述了每个进程的内部状态和缓冲区的内容。系统的初始配置中每个进程处于一个初始状态，缓冲区是空的。</p>
<p>一个步(step)将一个系统配置转变为另一个，一个step包括一个具体进程p的原始step。对于配置C，一个step可以分成两个阶段：</p>
<ol>
<li>执行receive(p)获取一个m，其中m可以是(0, 1, null)。</li>
<li>根据C中p的状态以及m的值，p进入一个新的状态并向其他进程发送有限个消息。</li>
</ol>
<p>由于进程是切换到确定状态的，则一个step完全由e=(p,m)决定，称e为事件（event）（可以把“事件”看做是p对m的接收），e(C)表示转变到的配置，称e可以应用到C。注意事件(p, null)总是可以应用到C。</p>
</blockquote>
<p>每次receive都有可能失败，那么(p, null)当然应该是可以应用到每个C的。</p>
<blockquote>
<p>C的议程（schedule）是一个有限或无限的从C开始的事件序列。应用一个schedule s称为一次运行。 如果s是有限的，用s(C)表示到达的配置，该配置被称作可到达的。从某个初始配置可到达的配置被认为是可访问的。文中提到的所有配置都是可访问的。</p>
</blockquote>
<p>那是肯定的。</p>
<blockquote>
<h3 id="引理1：schedule需要是可换的，即若s1-s2将C分别转换为C1-C2，且s1-s2中应用时间的进程不相交，那么s2可以应用到C1，s1也可以应用到C2，且到达同一配置。"><a href="#引理1：schedule需要是可换的，即若s1-s2将C分别转换为C1-C2，且s1-s2中应用时间的进程不相交，那么s2可以应用到C1，s1也可以应用到C2，且到达同一配置。" class="headerlink" title="引理1：schedule需要是可换的，即若s1, s2将C分别转换为C1, C2，且s1, s2中应用时间的进程不相交，那么s2可以应用到C1，s1也可以应用到C2，且到达同一配置。"></a>引理1：schedule需要是可换的，即若s1, s2将C分别转换为C1, C2，且<strong>s1, s2中应用时间的进程不相交</strong>，那么s2可以应用到C1，s1也可以应用到C2，且到达同一配置。</h3></blockquote>
<p>这也是肯定的，系统就是这么定义的。</p>
<blockquote>
<p>如果某个进程p处在yp=v的确定状态，则配置C具有确定值v（decision value）。以下条件满足时一致性协议是<strong>部分正确</strong>的：</p>
<ol>
<li>可达的配置最多只有一个确定值。（也就是所有处于确定状态的进程都对应同一个v）</li>
<li>所有可达的配置的确定值包含0和1。（协议需要有意义，值需要可以被选取到）</li>
</ol>
<p>一个进程p只要在运行中应用无限多的step，它就是是确保无错的，否则就有可能故障。当最多有一个进程可能故障时，所有发送给确保无错的进程的消息最终都被接收，运行是可以接受（admissible）的。</p>
<p>如果一次运行中有进程达到确定状态，则这次运行是决定（deciding）的。<strong>一个单个进程故障时仍完全正确的一致性协议P指的是当有一个进程异常时它是部分正确的，并且它的每个admissible run是deciding run（deciding run会让某个进程确定v，而因为P是部分正确的，进程只要处于确定状态那配置就有对应的确定值，因此admissible run会让配置确定值）。</strong></p>
</blockquote>
<p>admissible run算是比较宽容了。<br>部分正确的要求就比较严格，对应的paxos的话需要把learner看做是进程，那么paxos是部分正确的。<br>已经在确定状态的进程再执行一次receive后大概还是算达到确定状态，不过状态不会改变。<br>一个admissible run能不能是全都是e(p, null)？</p>
<h2 id="flp"><a href="#flp" class="headerlink" title="flp"></a>flp</h2><h3 id="定理1：没有一致性协议是单个进程故障时仍完全正确的"><a href="#定理1：没有一致性协议是单个进程故障时仍完全正确的" class="headerlink" title="定理1：没有一致性协议是单个进程故障时仍完全正确的"></a>定理1：没有一致性协议是单个进程故障时仍完全正确的</h3><blockquote>
<p>证明：假设P是单个进程故障时仍完全正确的，证明两条引理以推出矛盾。</p>
<p>基本思路是找到某些情况使得协议永远处于非确定状态。这涉及两个步骤：</p>
<ol>
<li>我们认为有一些还不确定会到达哪个确定状态的初始配置。</li>
<li>我们在这些初始配置上构造一个admissible run，在执行这次运行后系统仍不达到确定状态。</li>
</ol>
<p>C是一个配置，V是C到达的配置的确定值的集合。如果|V| = 2，则C是<strong>二价的</strong>（bivalent）。如果|V| = 1，则C是一价的。当C是一价的时候，用0-valent或1-valent表示C可达的配置对应的唯一的确定值。 由于P是完全正确的，并且admissible run是要存在的（不然还讨论啥），所以|V|一定不等于0。</p>
<h4 id="引理2：P有二价的初始配置。"><a href="#引理2：P有二价的初始配置。" class="headerlink" title="引理2：P有二价的初始配置。"></a>引理2：P有二价的初始配置。</h4><p>证明：假设不是，那P的初始状态只能是0-valent或1-valent的。如果两个初始配置只有一个进程p的初始值xp不同，把这两个初始配置看做是相邻的（adjacent），那么任何两个初始配置都由一系列初始配置连接起来，这个链上的初始配置两两相邻。 因此，<strong>必然存在0-valent和1-valent初始配置相邻的情况。把他俩叫做C0和C1，设p是他们俩xp不同的那个进程。</strong></p>
<p>考虑一个从C0开始的admissible deciding run，在这次运行中p不应用任何step，设对应schedule是s。那么s也可以应用于C1，自然C0和C1应用s之后对应的配置除了p的状态其他都相同。显然这两个配置的确定值相同（就把p看成故障了就可以了）。 如果该值是1，则C0是二价的; 否则，C1是二价的。得出矛盾。</p>
</blockquote>
<p>这还是比较明确的。</p>
<blockquote>
<h4 id="引理3：假设C是P的二价配置，e-p-m-是一个可以应用到C的事件。Eall是C不应用e时可达的配置集合，Dall是D-e-E-的集合，其中E属于Eall。-那么，Dall含有二价配置。"><a href="#引理3：假设C是P的二价配置，e-p-m-是一个可以应用到C的事件。Eall是C不应用e时可达的配置集合，Dall是D-e-E-的集合，其中E属于Eall。-那么，Dall含有二价配置。" class="headerlink" title="引理3：假设C是P的二价配置，e=(p, m)是一个可以应用到C的事件。Eall是C不应用e时可达的配置集合，Dall是D=e(E)的集合，其中E属于Eall。 那么，Dall含有二价配置。"></a>引理3：假设C是P的二价配置，e=(p, m)是一个可以应用到C的事件。Eall是C不应用e时可达的配置集合，Dall是D=e(E)的集合，其中E属于Eall。 那么，Dall含有二价配置。</h4><p>证明：首先e是可以应用到E的。因为schedule需要是可换的，那么p没应用step的E肯定可以应用e，然后对于p应用了step的E，因为消息是可以乱系到达的，p还是可以应用e对应的step，因此e一定可以应用到E。</p>
<p>仍然是假设D都是一阶的，构造矛盾。</p>
<p>假设存在C可达的i-valent的Ei，i={1, 2}（因为C是二价的，而且假设应用两个step后D必然是一价的，因此Ei肯定存在，但是也不一定属于D）。</p>
<ol>
<li>如果Ei属于Eall，那么取Fi=e(Ei)，Fi属于Dall。</li>
<li>否则e肯定已经在到达Ei的过程中被应用过了，那么一定有属于Dall的Fi可以到达Ei。</li>
</ol>
<p>这两种情况中Fi都是i-valent的（因为属于D），<strong>可以得出Dall一定是包含0-valent和1-valent的配置。</strong></p>
<p>若一个配置只应用一个step就可以到达另一个，称这两个配置是邻居（neighbor）。</p>
<p>通过一个简单的归纳，Eall中存在邻居C0和C1（并不一定是一价的，但是C0要能达到0，C1要能达到1），Di=e(Ci)（Di肯定是一价的）。设C1=e’(C0)，e’=(p’, m’)。</p>
</blockquote>
<p>m是不是可以是null？看起来不能，m是null的话就没意思了。</p>
<p>C是不是可以属于Eall？是，C是C不应用e时可达的配置之一听起来没啥毛病。。</p>
<p>再说明下上面那个简单的归纳：</p>
<p>那么这样算的话，首先Eall中肯定是有邻居配置的，那么如果不存在邻居C0和C1，也就是任意的erandom(C0)都不能到C1，那Eall中的所有C0都是一价的，和C属于Eall冲突了。</p>
<blockquote>
<ol>
<li>情况1：如果p’ ≠ p，则由引理1可得 D1 = e(C1) = e(e’(C0)) = e’(e(C0)) = e(D0) 。与D都是一阶的假设矛盾。</li>
<li>情况2：如果p’ = p，那么考虑任意的从C0开始的有限step的<strong>deciding run</strong>，并且其中p不应用任何step，取其对应的schedule s，取<strong>A = s(C0)</strong>，由引理1，s可以应用到Ci和Di的任一个。因为Di是一价的，所以Ei = s(Di) 自然也是i-valent的，由引理1可知A可以应用e和e’，e(A) = e(s(C0)) = s(D0) = E0 ，而e(e’(A)) = e(e’(s(C0))) = s(e(e’(C0))) = s(e(C1)) = s(D1) = E1，因此A是二价的。但是基于部分正确和deciding run的定义，A不能是二价的，因此矛盾。</li>
</ol>
<p>由情况1、2，Dall中包含二价配置。</p>
</blockquote>
<p>这样看的话一个step不足以让二价配置必然成为一价配置。</p>
<blockquote>
<p>若admissible run都是deciding run，当二价配置开始执行一个admissible run时，他最终成为一价配置，这其中最少有一个step会使得某个二价配置成为一价配置，引理2表明这个step不存在。</p>
<p>构造这样的admissible run：一个run是从初始配置开始分阶段（stage）构造的。我们通过以下方式确保run是admissible run。最初以任意顺序维护一个进程队列，并且配置中的缓冲区按照消息被发送的时间对消息排序，最早的排在第一位。一个阶段的执行包括一个或多个step。</p>
<p>一个阶段执行的step数量随意，但是最后一个step对应的process一定是队头的process，他会receive他对应的第一个消息（根据定义，receive不必然返回m），然后队头会挪到队尾，这个阶段结束。如果无限执行这样的阶段，那任何一个进程都会应用无限step以确保每个消息被receive。因此run是admissible run。在这个run之中的问题就是避免配置永远不能成为确定配置。</p>
<p>设C0是二价初始配置，由引理2，C0存在。从CO开始执行，并且我们可以通过以下方式确保每个stage开始执行是配置是二价的。假设配置C是二价的，进程p在队头，m是C的缓冲区中对应到p的最早的消息（有就是0或1，没有就null）。令e = (p，m)，根据引理3，可以通过一个以e结束的schdule把C切换到二价配置C’。这样的话每个stage都以二价配置开始，以二价配置结束，一个永远达不到确定状态的admissible run就被构造了。</p>
<p>这样的话定理1得证。</p>
</blockquote>
<h3 id="Initially-Dead-Processes"><a href="#Initially-Dead-Processes" class="headerlink" title="Initially Dead Processes"></a>Initially Dead Processes</h3><blockquote>
<p>原文还有一个部分正确的一致性协议，如果大部分进程是正常的并且协议执行期间进程没死就能保证一致。事先进程不需要知道哪个进程是死的。</p>
<p>该协议分两个阶段进行。</p>
<p>第一阶段，所有进程构造了一个有向图G，每个进程对应一个节点。每个进程广播一个包含进程号的消息，然后监听L-1个其他进程的消息，其中L = ⌈ (N + 1) / 2 ⌉。当且仅当j从i接收一个消息，G就有i到j的边。 因此，G的入度是L-1。<br>好像不一定是全连通的。</p>
<p>在第二阶段，进程构造G+（G的传递闭包），该过程结束后每个进程k知道所有G+中终点是k的的边(j, k)以及j的初始值。</p>
<p>为了实现这个阶段，每个进程向所有其他进程广播进程号、初始值和他在第一阶段监听的L-1个进程的名字。然后等待直到收到他在G中的每一个祖先的第二阶段的消息。起初，它只知道在第一阶段听到的L-1个进程，但是它从阶段2的信息中感知到其他的祖先。所有的进程等待，直到所有目前已知的进程都被听到。</p>
<p>在这时每个进程都知道自己的所有祖先和G中这些祖先相关的边。根据这些信息，它计算G+上每个祖先关联的边。然后确定它的哪些祖先属于G +的初始集合（即入度为0的进程的集合）。为打到这个目的，当且仅当k是每个k的祖先j的祖先时，k属于G+的初始集合。由于G+中的每个节点至少有L-1个前任，所以只能有一个初始集团;，这个初始集团至少具有基数L，并且完成第二阶段的每个过程都精确地知道组成它的进程。</p>
<p>最后，每个进程都采用事先协定的规则，以初始集团的进程初始值为准确定值。既然所有的进程都知道了初始集团中所有成员的初始值，他们都会选取同样的值。</p>
<p>该协议表明定理2的正确性：</p>
<h4 id="定理2：存在部分正确的一致性协议，只要执行进程中进程死掉并且大多数的进程最初是活的，其中所有正常进程总是达成相同的确定值。"><a href="#定理2：存在部分正确的一致性协议，只要执行进程中进程死掉并且大多数的进程最初是活的，其中所有正常进程总是达成相同的确定值。" class="headerlink" title="定理2：存在部分正确的一致性协议，只要执行进程中进程死掉并且大多数的进程最初是活的，其中所有正常进程总是达成相同的确定值。"></a>定理2：存在部分正确的一致性协议，只要执行进程中进程死掉并且大多数的进程最初是活的，其中所有正常进程总是达成相同的确定值。</h4></blockquote>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>就那样吧，受教了。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/algorithm/" rel="tag"># algorithm</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/07/poj-1753/" rel="next" title="poj-1753 Flip Game">
                <i class="fa fa-chevron-left"></i> poj-1753 Flip Game
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/22/poj-2965/" rel="prev" title="poj-2965">
                poj-2965 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="Type 2B" />
            
              <p class="site-author-name" itemprop="name">Type 2B</p>
              <p class="site-description motion-element" itemprop="description">白金blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#需要解决的问题"><span class="nav-number">1.</span> <span class="nav-text">需要解决的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引理1：schedule需要是可换的，即若s1-s2将C分别转换为C1-C2，且s1-s2中应用时间的进程不相交，那么s2可以应用到C1，s1也可以应用到C2，且到达同一配置。"><span class="nav-number">1.1.</span> <span class="nav-text">引理1：schedule需要是可换的，即若s1, s2将C分别转换为C1, C2，且s1, s2中应用时间的进程不相交，那么s2可以应用到C1，s1也可以应用到C2，且到达同一配置。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flp"><span class="nav-number">2.</span> <span class="nav-text">flp</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定理1：没有一致性协议是单个进程故障时仍完全正确的"><span class="nav-number">2.1.</span> <span class="nav-text">定理1：没有一致性协议是单个进程故障时仍完全正确的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引理2：P有二价的初始配置。"><span class="nav-number">2.1.1.</span> <span class="nav-text">引理2：P有二价的初始配置。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引理3：假设C是P的二价配置，e-p-m-是一个可以应用到C的事件。Eall是C不应用e时可达的配置集合，Dall是D-e-E-的集合，其中E属于Eall。-那么，Dall含有二价配置。"><span class="nav-number">2.1.2.</span> <span class="nav-text">引理3：假设C是P的二价配置，e=(p, m)是一个可以应用到C的事件。Eall是C不应用e时可达的配置集合，Dall是D=e(E)的集合，其中E属于Eall。 那么，Dall含有二价配置。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Initially-Dead-Processes"><span class="nav-number">2.2.</span> <span class="nav-text">Initially Dead Processes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定理2：存在部分正确的一致性协议，只要执行进程中进程死掉并且大多数的进程最初是活的，其中所有正常进程总是达成相同的确定值。"><span class="nav-number">2.2.1.</span> <span class="nav-text">定理2：存在部分正确的一致性协议，只要执行进程中进程死掉并且大多数的进程最初是活的，其中所有正常进程总是达成相同的确定值。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#感想"><span class="nav-number">3.</span> <span class="nav-text">感想</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Type 2B</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
